import sys
import os
import warnings
import pickle
from datetime import date, datetime
from typing import List, Union
import pandas as pd
import files_rc  # This RUNS on RxUNTIME
from PyQt6 import QtWidgets, uic
from PyQt6.QtCore import Qt

# Suppress the specific warning related to pandas and the database connection
warnings.filterwarnings("ignore", category=UserWarning, module="pandas")

def date_converter(date_string: str) -> str:
    """
        Helper function that accepts a date in string format.
        It returns a string representation of the date in the format YYYY/MM/DD.
    """
    # Parse the date string into a datetime object
    date_object = datetime.strptime(date_string, "%a %b %d %Y")
    datetime64_object = date_object.strftime('%Y/%m/%d')
    return datetime64_object

class Helpers:
    def __init__(self) -> None:
        self.drive_letters = self.get_drive_letters()

    def get_drive_letters(self) -> List[str]:
        drive_letters = []
        for drive in range(65, 91):  # ASCII values for A-Z
            drive_letter = chr(drive) + ':\\'
            if os.path.exists(drive_letter):
                drive_letters.append(drive_letter)
        return drive_letters

    def get_company_folders(self, directory_path) -> Union[List[str], bool]:
        subfolder_names = False
        directory_path = os.path.join(directory_path, "bank_recon")
        if os.path.exists(directory_path):
            subfolder_names = [d for d in os.listdir(directory_path) if os.path.isdir(os.path.join(directory_path, d))]
        return subfolder_names

class Ui(QtWidgets.QMainWindow):
    def __init__(self):
        """
            Initialize the window and the UI.
        """
        super(Ui, self).__init__()

        uic.loadUi('basic.ui', self)
        self.helper = Helpers()
        self.setup_vars()
        self.show()

    def setup_vars(self):
        self.btn_close.clicked.connect(self.closeApplication)
        self.btn_maximize_restore.clicked.connect(self.toggleMaximize)
        self.btn_minimize.clicked.connect(self.toggleMinimize)

        DRIVE_LETTERS = self.helper.drive_letters
        self.drive_combo_box.addItems(DRIVE_LETTERS)
        self.drive_box_change(0)
        self.drive_combo_box.currentIndexChanged.connect(self.drive_box_change)
        self.create_csv_button.clicked.connect(self.create_csv)

    def drive_box_change(self, index):
        drive_letter = self.drive_combo_box.itemText(index) if self.drive_combo_box.itemText(index) else self.drive_combo_box.currentText()
        companies = self.helper.get_company_folders(drive_letter)
        self.company_box.clear()
        if companies:
            self.company_box.addItems(companies)
            companies_available = len(companies)
            self.status_box.setText(f"STATUS: {companies_available} company found")
        else:
            self.status_box.setText("STATUS: No Company Folder Found")

    def closeApplication(self):
        self.close()

    def toggleMaximize(self):
        if self.isMaximized():
            self.showNormal()
        else:
            self.showMaximized()

    def toggleMinimize(self):
        if self.isMinimized():
            self.showNormal()
        else:
            self.showMinimized()

    def create_csv(self):
        self.start = self.start_date_widget.selectedDate()
        start = self.start.toString('yyyy/MM/dd')

        self.end = self.end_date_widget.selectedDate()
        end = self.end.toString('yyyy/MM/dd')

        self.progressBar.setVisible(True)
        self.progressBar.setValue(10)
        company = self.company_box.currentText()
        directory_path = self.drive_combo_box.currentText()
        directory_path = os.path.join(directory_path, "bank_recon", self.company_box.currentText())

        handler = MainHandler(start, end, company, directory_path)
        handler.run()
        self.progressBar.setValue(100)

class MainHandler:
    def __init__(self, start, end, company, directory_path) -> None:
        self.company = company
        self.start = start
        self.end = end
        Date_From = datetime.strptime(self.start, '%Y/%m/%d')
        Year_From = Date_From.year
        Month_From = Date_From.month
        Day_From = Date_From.day

        Date_To = datetime.strptime(self.end, '%Y/%m/%d')
        Year_To = Date_To.year
        Month_To = Date_To.month
        Day_To = Date_To.day

        if self.company == "GW":
            GL = pickle.load(open(f'{directory_path}/GW.pkl', 'rb'))
            print(GL.columns)
            GL['YEAR'] = pd.DatetimeIndex(GL['trndate']).year
            GL['MONTH'] = pd.DatetimeIndex(GL['trndate']).month
            BANK_RECON_GL = GL.loc[
                (GL['MONTH'] <= 12) &
                (GL['subacct'] == '1001') &
                (GL['trndate'] >= date(year=Year_From, month=Month_From, day=Day_From)) &
                (GL['trndate'] <= date(year=Year_To, month=Month_To, day=Day_To))
            ][[
                'trndate',
                'trnno',
                'subacct',
                'payee',
                'dr_amt',
                'cr_amt',
                'net_',
            ]]
            BANK_RECON_GL.to_csv(f"{self.company}_gl_data.csv", index=False)

        else:
            self.TRN = pickle.load(open(f'{directory_path}/TRN.pkl', 'rb'))
            self.TRM = pickle.load(open(f'{directory_path}/TRM.pkl', 'rb'))
            self.TRN_CHEQUE = pickle.load(open(f'{directory_path}/TRN_CHEQUE.pkl', 'rb'))

            self.TRN = self.TRN[['TRNTYPE', 'TRNNO', 'TRNDATE', 'ACCTNO', 'ACCTNAME', 'SUBACCT', 'SUBNAME', 'DEPT_NO', 'DEPT_NAME', 'DR_AMT', 'CR_AMT', 'NAME', 'ATCI', 'ATCC', 'DE', 'DSN', 'PayType']]
            self.TRM = self.TRM[['TRNTYPE', 'TRNNO', 'TRNDATE', 'REMARK', 'OTHER_01', 'OTHER_02', 'OTHER_03', 'NAME']]
            self.TRN_CHEQUE = self.TRN_CHEQUE[['TRNTYPE', 'TRNNO', 'TRNDATE', 'PAYEE', 'ACCTNO', 'CHEQUENO', 'CHEQUEDATE', 'AMOUNT']]

            self.TRN.sort_values(by=['TRNDATE', 'TRNNO'], ascending=True, inplace=True)

            self.TRN = self.TRN.loc[
                (self.TRN['TRNDATE'] >= datetime(year=Year_From, month=Month_From, day=Day_From)) &
                (self.TRN['TRNDATE'] <= datetime(year=Year_To, month=Month_To, day=Day_To))
            ]

            self.TRM.sort_values(by=['TRNDATE', 'TRNNO'], ascending=True, inplace=True)

            self.TRM = self.TRM.loc[
                (self.TRM['TRNDATE'] >= datetime(year=Year_From, month=Month_From, day=Day_From)) &
                (self.TRM['TRNDATE'] <= datetime(year=Year_To, month=Month_To, day=Day_To))
            ]

            self.TRN_CHEQUE.sort_values(by=['TRNDATE', 'TRNNO'], ascending=True, inplace=True)

            self.TRN_CHEQUE = self.TRN_CHEQUE.loc[
                (self.TRN_CHEQUE['TRNDATE'] >= datetime(year=Year_From, month=Month_From, day=Day_From)) &
                (self.TRN_CHEQUE['TRNDATE'] <= datetime(year=Year_To, month=Month_To, day=Day_To))
            ]

    def run(self):
        self.TRN.sort_values(by=['TRNDATE', 'TRNNO'], ascending=True, inplace=True)
        self.TRM.sort_values(by=['TRNDATE', 'TRNNO'], ascending=True, inplace=True)
        self.TRN_CHEQUE.sort_values(by=['TRNDATE', 'TRNNO'], ascending=True, inplace=True)

        GL1 = pd.merge(left=self.TRN, right=self.TRM, on=['TRNNO', 'TRNDATE'], how='left', suffixes=('', '_TRM'))

        GL1['PAYEE'] = GL1.apply(lambda x: x['OTHER_01'] if x['OTHER_01'] is not None else x['NAME_TRM'], axis=1).astype(str)

        GL1['YEAR'] = pd.DatetimeIndex(GL1['TRNDATE']).year
        GL1['MONTH'] = pd.DatetimeIndex(GL1['TRNDATE']).month
        GL1['NET_AMT'] = GL1['DR_AMT'] - GL1['CR_AMT']
        GL1['REMARK'] = GL1['REMARK'].astype(str)
        GL1['CASH_TRN_REF'] = GL1.apply(lambda x: x['TRNNO'] + x['SUBACCT'] if x['ACCTNO'] == '1001' and x['CR_AMT'] != 0 else None, axis='columns').astype(str)
        GL1.reset_index(inplace=True)
        GL1 = GL1.rename(columns={'index': 'ID'})

        TRN_CHEQUE_DF = pd.DataFrame(self.TRN_CHEQUE)
        TRN_CHEQUE_DF['CASH_TRN_REF'] = self.TRN_CHEQUE['TRNNO'] + self.TRN_CHEQUE['ACCTNO']
        TRN_CHEQUE_DF.reset_index(inplace=True)
        TRN_CHEQUE_DF = TRN_CHEQUE_DF.rename(columns={'index': 'ID_CHK'})

        GL_With_Check = pd.merge(left=GL1, right=TRN_CHEQUE_DF, on=['CASH_TRN_REF', 'TRNDATE'], how='left', suffixes=('', '_CHK'))
        GL_With_Check['Duplicate Entry?'] = GL_With_Check.duplicated(subset='ID', keep='first')
        GL_With_Check['Duplicate Cheque Entry?'] = GL_With_Check.duplicated(subset='ID_CHK', keep='first')
        GL_With_Check['DR_AMT'] = GL_With_Check.apply(lambda x: 0 if x['Duplicate Entry?'] else x['DR_AMT'], axis='columns').astype(float)
        GL_With_Check['CR_AMT'] = GL_With_Check.apply(lambda x: 0 if x['Duplicate Entry?'] else x['CR_AMT'], axis='columns').astype(float)
        GL_With_Check['AMOUNT'] = GL_With_Check.apply(lambda x: 0 if x['Duplicate Cheque Entry?'] else x['AMOUNT'], axis='columns').astype(float).fillna(0)
        GL_With_Check['CR_AMT_2'] = GL_With_Check.apply(lambda x: x['AMOUNT'] if x['AMOUNT'] != 0 or not pd.isna(x['CHEQUENO']) else x['CR_AMT'], axis='columns').astype(float)
        GL_With_Check['NET_AMT'] = GL_With_Check['DR_AMT'] - GL_With_Check['CR_AMT_2']
        GL_With_Check['TRANSACTION REFERENCE'] = GL_With_Check.apply(lambda x: x['OTHER_03'] if x['TRNTYPE'] == '03' else x['CHEQUENO'], axis='columns').astype(str).fillna('')

        GL_With_Check.loc[~GL_With_Check['PAYEE_CHK'].isnull(), 'PAYEE'] = GL_With_Check.loc[~GL_With_Check['PAYEE_CHK'].isnull(), 'PAYEE_CHK']

        GL = pd.DataFrame(GL_With_Check)
        GL = GL.loc[(GL['NET_AMT'] != 0)]
        BALANCE = pd.DataFrame(GL['NET_AMT']).sum(axis='rows')

        Date_From = datetime.strptime(self.start, '%Y/%m/%d')
        Year_From = Date_From.year
        Month_From = Date_From.month
        Day_From = Date_From.day

        Date_To = datetime.strptime(self.end, '%Y/%m/%d')
        Year_To = Date_To.year
        Month_To = Date_To.month
        Day_To = Date_To.day

        BANK_RECON_GL = GL.loc[
            (GL['MONTH'] <= 12) &
            (GL['ACCTNO'] == '1001') &
            (GL['TRNDATE'] >= datetime(year=Year_From, month=Month_From, day=Day_From)) &
            (GL['TRNDATE'] <= datetime(year=Year_To, month=Month_To, day=Day_To))
        ][[
            'TRNDATE',
            'TRNNO',
            'SUBACCT',
            'PAYEE',
            'TRANSACTION REFERENCE',
            'DR_AMT',
            'CR_AMT_2',
            'NET_AMT',
            'CHEQUEDATE',
            'CHEQUENO',
            'ACCTNO'
        ]]

        BANK_RECON_GL.rename(columns={'PAYEE': 'OTHER_01', 'TRANSACTION REFERENCE': 'OTHER_03', 'CR_AMT_2': 'CR_AMT', 'NET_AMT': 'NET'}, inplace=True)
        BANK_RECON_GL['FROM'] = date(Year_From, Month_From, Day_From)
        BANK_RECON_GL['TO'] = date(Year_To, Month_To, Day_To)
        BANK_RECON_GL['REF_1'] = ''
        BANK_RECON_GL['REF_2'] = ''
        BANK_RECON_GL.fillna('', inplace=True)
        BANK_RECON_GL.replace({None: ''}, inplace=True)
        BANK_RECON_GL.replace('None', '', inplace=True)
        BANK_RECON_GL.replace('nan', '', inplace=True)
        BANK_RECON_GL["OTHER_03"] = BANK_RECON_GL["OTHER_03"].astype(str)
        BANK_RECON_GL['TRNDATE'] = BANK_RECON_GL['TRNDATE'].dt.strftime('%m/%d/%Y')

        def convert_to_string_if_not_number(value):
            if pd.api.types.is_numeric_dtype(value):
                return value
            else:
                return str(value)

        BANK_RECON_GL = BANK_RECON_GL.applymap(convert_to_string_if_not_number)
        BANK_RECON_GL.to_csv(f"{self.company}_gl_data.csv", index=False)

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = Ui()
    window.setWindowTitle("PyQt-Frameless-Window")
    window.show()
    sys.exit(app.exec())
s